{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Presentacion","text":""},{"location":"#autores","title":"Autores","text":""},{"location":"#nombre","title":"Nombre","text":"<p>Rodrigo Zerme\u00f1o Cervantes</p> <p></p>"},{"location":"#fecha-de-nacimiento","title":"Fecha de nacimiento","text":"<p>Nac\u00ed el 23 de octubre del 2007.</p>"},{"location":"#intereses","title":"Intereses","text":"<p>Soy un apasionado del mundo automotriz y me encanta aprender sobre tecnolog\u00eda y mec\u00e1nica. Siempre he sido una persona activa; empec\u00e9 jugando f\u00fatbol y hoy en d\u00eda disfruto practicar tenis y p\u00e1del. Actualmente estudio Ingenier\u00eda Mecatr\u00f3nica en la Ibero Puebla, con el objetivo de combinar mi inter\u00e9s por la innovaci\u00f3n con mi gusto por los veh\u00edculos y la ingenier\u00eda.</p>"},{"location":"#logros","title":"Logros","text":"<p>-Logre un 3er puesto en un torneo de karting categoria avanzada sin haber competido antes.</p> <p>-Me destaco en deportes como el tenis,padel y pickleball</p>"},{"location":"#nombre_1","title":"Nombre","text":"<p>Leonardo Barrientos Miguel</p> <p></p> <p>Nac\u00ed el 23 de octubre del 2007</p>"},{"location":"#mis-intereses","title":"Mis intereses","text":"<p>Me considero a mi mismo un gran fanatico del baloncesto, usualmente lo practicaba he incluso llegue a estar en el equipo representativo de mi preparatoria. Por otro lado desde peque\u00f1o me gusto el tema de la rob\u00f3tica y en general la ingenier\u00eda, luego me adentre m\u00e1s en el tema y fue lo de las cosas que mas me gustaron, es por esta raz\u00f3n que hoy mismo soy estudiante de ingenier\u00eda mecatr\u00f3nica en la Ibero Puebla.</p>"},{"location":"#logros-de-los-que-estoy-orgulloso","title":"Logros de los que estoy orgulloso","text":"<ul> <li>Por un lado algo que mencione anteriormente fue el ser parte del equipo representativo de baloncesto de mi preparatoria y no solo eso, si no que llegar a ser del cuadro titutal.</li> <li>Y por otro lado un logro m\u00e1s \"academico\" que me enorgullece fue haber participado en las olimpiadas nacionales de matematicas hace un a\u00f1o y lograr llegar a la fase estatal consiguiendo un 3er lugar.</li> </ul>"},{"location":"#contactos","title":"Contactos","text":"<p>Rodrigo: 203902@iberopuebla.mx</p> <p>Leo: 203586@iberopuebla.mx</p>"},{"location":"Ball_and_plate_system/","title":"Proyecto Final","text":""},{"location":"Ball_and_plate_system/#nombre-del-proyecto-ball-and-plate-system","title":"Nombre del proyecto: Ball and Plate system","text":""},{"location":"Ball_and_plate_system/#autores","title":"Autores","text":"<ul> <li>Barrientos Miguel Leonardo</li> <li>Zerme\u00f1o Cervantes Rodrigo</li> </ul>"},{"location":"Ball_and_plate_system/#asignatura-introduccion-a-la-mecatronica","title":"Asignatura: Introducci\u00f3n a la Mecatronica","text":""},{"location":"Ball_and_plate_system/#fecha-5-de-diciembre-del-2025","title":"Fecha: 5 de Diciembre del 2025","text":""},{"location":"Ball_and_plate_system/#descripcion","title":"Descripci\u00f3n","text":"<p>En este proyecto final desarrollamos un Ball and Plate System, un mecanismo mecatr\u00f3nico capaz de mantener una pelota equilibrada sobre una plataforma mediante la variaci\u00f3n de \u00e1ngulos en una placa superior.</p> <p>El sistema utiliza cuatro servomotores, los cuales modifican la inclinaci\u00f3n de la placa en los ejes X y Y. A trav\u00e9s del control coordinado de estos servomotores, la plataforma es capaz de moverse en diferentes direcciones para dirigir o estabilizar la pelota en una posici\u00f3n deseada.</p> <p>Este mecanismo es una base importante para sistemas de control avanzados, como plataformas estabilizadoras, robots equilibristas o sistemas de visi\u00f3n con retroalimentaci\u00f3n. El proyecto se encuentra documentado y versionado en GitHub, donde se registran los avances, diagramas y c\u00f3digos implementados.</p>"},{"location":"Ball_and_plate_system/#objetivos","title":"Objetivos","text":""},{"location":"Ball_and_plate_system/#general","title":"General","text":"<p>Dise\u00f1ar y programar un sistema mecatr\u00f3nico de control de inclinaci\u00f3n capaz de mover una plataforma en dos ejes mediante servomotores para lograr el equilibrio din\u00e1mico de una pelota.</p>"},{"location":"Ball_and_plate_system/#especificos","title":"Especificos","text":"<ul> <li>Implementar la comunicaci\u00f3n y control de 4 servomotores utilizando un microcontrolador (Arduino/ESP32)..  </li> <li>Dise\u00f1ar la estructura mec\u00e1nica para mover la placa superior mediante un sistema articulado. </li> <li>Desarrollar el c\u00f3digo para mover la plataforma en diferentes direcciones variando los \u00e1ngulos de los servos.</li> <li>Comprender la relaci\u00f3n entre los movimientos de los servomotores y la inclinaci\u00f3n resultante de la placa.</li> <li>Documentar el proceso mec\u00e1nico, electr\u00f3nico y de programaci\u00f3n del sistema.</li> </ul>"},{"location":"Ball_and_plate_system/#alcance-y-exclusiones","title":"Alcance y Exclusiones","text":"<p>-Incluye:</p> <ul> <li>Montaje mec\u00e1nico con una placa m\u00f3vil y cuatro servos.</li> <li>C\u00f3digo para controlar la inclinaci\u00f3n de la placa en ambos ejes. </li> <li>Pruebas manuales de inclinaci\u00f3n mediante valores programados.</li> <li>Calibraci\u00f3n b\u00e1sica del rango de movimiento de los servos.</li> </ul> <p>-No Incluye: </p>"},{"location":"Ball_and_plate_system/#procedimiento","title":"Procedimiento","text":""},{"location":"Ball_and_plate_system/#diseno-mecanico-del-sistema","title":"Dise\u00f1o Mec\u00e1nico Del Sistema","text":"<p>Se construy\u00f3 una plataforma con dos niveles:</p> <p>1- Placa inferior fija, donde se colocan los servomotores.</p> <p>2- Placa superior m\u00f3vil, unida mediante r\u00f3tulas o uniones articuladas.</p> <p>Cada uno de los dos servomotores est\u00e1 conectado a un punto distinto de la placa m\u00f3vil. Al variar el \u00e1ngulo de los servos, se altera la altura relativa de cada esquina de la plataforma, generando inclinaci\u00f3n en dos ejes.</p> <p>Tambien se incluye una webcam mediante la cual recibimos la imagen del de la parte superior de la plataforma donde es colocada la pelota. El objetivo de esto es que mediante la retroaliemtaci\u00f3n visual recibida por parte de la webcam , el sistema pueda compensar perturbaciones y mantener la pelota en la plataforma sin que se caiga de esta.</p> <p>Especificaciones: </p> <ul> <li> <p>Los servos que ocupamos fueron unos Servomotores Mg996r 15kg de 180\u00ba    Y las siguentes medidas:</p> <p>-Longitud del cable: 30cm, cable de se\u00f1al (amarillo), rojo (alimentaci\u00f3n), marr\u00f3n (masa).</p> <p>-Tama\u00f1o :40.7 * 19.7 * 42.9mm</p> </li> <li> <p>Por otro lado la plataforma fue realizada con madera mdf de un grosor de 3 mm con un \u00e1rea de 20 * 20 cm.</p> </li> <li> <p>Por ultimo, se realizo una base en forma de cruz para sostener los servos de forma horizontal, la cual cada parte tenia una longitud aproximada a 14 cm con un ancho de 3.5 cm y un alto de 2 cm, dejando en cada esquina un compartimento para el servo, con las medidas exactas de estos. Ademas de una parte central de 3.5 * 3.5 * 2cm la cual unia estas partes entre si mediante unos tubos los cuales tenian 1cm de diametro y los cuales extruimos 2 cm para que todo pudiese unirse y formar la base.</p> </li> </ul> <p></p> <ul> <li>Por otra parte, se procedi\u00f3 al dise\u00f1o y fabricaci\u00f3n de un par de brazos destinados a acoplarse a los servomotores. Esta configuraci\u00f3n, al conectar los brazos a la plataforma y mantenerlos sujetos a los servos, permiti\u00f3 el correcto proceso de nivelaci\u00f3n de la plataforma.</li> </ul> <p></p>"},{"location":"Ball_and_plate_system/#programacion-del-codigo","title":"Programaci\u00f3n del c\u00f3digo","text":"<p>Por otro lado y probablemente la parte m\u00e1s importante para que funionara el mecanismo, es el codigo, el cual consistio en 2 partes, el codigo realizado en python mediante Visual Studio.</p> <p>El c\u00f3digo desarrollado en Visual Studio tiene como prop\u00f3sito realizar el procesamiento visual y el control principal del sistema Ball and Plate. Su funci\u00f3n consiste en detectar en tiempo real la posici\u00f3n de una pelota sobre la plataforma y generar las se\u00f1ales de correcci\u00f3n necesarias para mantenerla en equilibrio.</p> <p>Para lograr esto, el programa utiliza una c\u00e1mara conectada al sistema para capturar video en vivo. Mediante t\u00e9cnicas de visi\u00f3n artificial (OpenCV), identifica la pelota a trav\u00e9s de un filtrado por color en el espacio HSV y determina sus coordenadas dentro del cuadro de imagen. Una vez obtenida la posici\u00f3n, el algoritmo calcula el error respecto al centro de la plataforma y aplica un control del tipo PD (Proporcional\u2013Derivativo) para generar una respuesta din\u00e1mica y estable.</p> <p>El resultado de este c\u00e1lculo se traduce en dos \u00e1ngulos de inclinaci\u00f3n (eje X y eje Y), los cuales se env\u00edan de manera continua al microcontrolador ESP32 mediante comunicaci\u00f3n Bluetooth. Finalmente, estos valores ser\u00e1n interpretados por el sistema Arduino/ESP32 para ajustar los servomotores y as\u00ed modificar la inclinaci\u00f3n de la base f\u00edsica.</p> <pre><code>import cv2\nimport numpy as np\nimport bluetooth\nimport time\n\n# = BLUETOOTH =\ndevice_mac = \"7C:9E:BD:70:0A:1E\"   # MISMA MAC DEL ESP32\nport = 1\n\n# =PAR\u00c1METROS SERVOS (2 EJES) =\n# SERVO_X controla inclinaci\u00f3n eje X (izquierda/derecha)\n# SERVO_Y controla inclinaci\u00f3n eje Y (arriba/abajo)\nNEUT_X = 180   # neutro a 180\u00b0\nNEUT_Y = 180   # neutro a 180\u00b0\n\n#  MODO TEST (para exagerar el movimiento) \nTEST_MODE = True   # Cambia a False cuando ya quieras algo m\u00e1s fino\n\nif TEST_MODE:\n    # Mucho m\u00e1s movimiento de servos\n    MAX_SERVO_OFFSET_X = 70.0   # rango de inclinaci\u00f3n en X (grados)\n    MAX_SERVO_OFFSET_Y = 45.0   # rango de inclinaci\u00f3n en Y (grados)\n\n    # Control m\u00e1s agresivo y SIN derivada (m\u00e1s f\u00e1cil ver el sentido)\n    KpX = 2.0\n    KdX = 0.0\n\n    KpY = 2.0\n    KdY = 0.0\nelse:\n    # Valores m\u00e1s tranquilos para uso normal\n    MAX_SERVO_OFFSET_X = 50.0\n    MAX_SERVO_OFFSET_Y = 40.0\n\n    KpX = 0.8\n    KdX = 0.2\n\n    KpY = 0.8\n    KdY = 0.2\n\n# = FLAGS DE ORIENTACI\u00d3N (LOS VAS CAMBIANDO EN VIVO) =\nINVERT_X = False   # lo puedes cambiar con la tecla 'x'\nINVERT_Y = False   # lo puedes cambiar con la tecla 'y'\nSWAP_AXES = False  # si True, intercambia X&lt;-&gt;Y (tecla 's')\n\nalpha = 0.8          # filtro para derivada\nMIN_DT_CMD = 0.015   # 15 ms (~66 Hz m\u00e1x)\n\nlast_cmd_time = 0.0\nlast_time = time.time()\n\nlast_errx = 0.0\nlast_erry = 0.0\ndxf = 0.0\ndyf = 0.0\n\n# Centro calibrado de la plataforma (en p\u00edxeles de la imagen)\ncenterX = None\ncenterY = None\n\n# \u00daltima posici\u00f3n conocida de la pelota (para la tecla 'b')\nlast_ball_x = None\nlast_ball_y = None\n\n# = CONEXI\u00d3N BLUETOOTH =\nsock = None\nprint(\"Intentando conectar al ESP32 por Bluetooth...\", device_mac)\nwhile True:\n    try:\n        sock = bluetooth.BluetoothSocket()\n        sock.settimeout(10)\n        sock.connect((device_mac, port))\n        print(\" Conectado al ESP32!\")\n        break\n    except Exception as e:\n        print(\"Error de conexi\u00f3n, reintentando:\", e)\n        time.sleep(1)\n\n# = ENVIAR NEUTRO INICIAL A 180\u00b0 EN LOS 2 SERVOS =\ntry:\n    cmd_init = f\"ANG:{NEUT_X},{NEUT_Y}\\n\"\n    sock.send(cmd_init.encode())\n    last_cmd_time = time.time()\n    print(\"Posici\u00f3n inicial 180\u00b0 enviada:\", cmd_init.strip())\nexcept Exception as e:\n    print(\" Error al enviar posici\u00f3n inicial:\", e)\n\n# = C\u00c1MARA (LA QUE VE LA PLATAFORMA) =\n# Cambia 1 a 0 si tu otra c\u00e1mara es la que ve la plataforma\nvideo = cv2.VideoCapture(1)\n\n# =RANGO HSV PARA LA PELOTA (EJEMPLO: NARANJA) =\nLOWER = np.array([10, 150, 120], np.uint8)\nUPPER = np.array([25, 255, 255], np.uint8)\n\nkernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (3, 3))\n\nwhile True:\n    ok, frame = video.read()\n    if not ok:\n        break\n\n    # Si la c\u00e1mara te da la imagen al rev\u00e9s y quieres voltearla:\n    # frame = cv2.flip(frame, 1)\n\n    h, w = frame.shape[:2]\n\n    # Si a\u00fan no hay centro calibrado, por defecto usa el centro de la imagen\n    if centerX is None or centerY is None:\n        centerX = w // 2\n        centerY = h // 2\n\n    now = time.time()\n    dt = now - last_time if now &gt; last_time else 0.01\n    send_allowed = (now - last_cmd_time) &gt;= MIN_DT_CMD\n\n    # --- Detecci\u00f3n de pelota por color ---\n    hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)\n    mask = cv2.inRange(hsv, LOWER, UPPER)\n    mask = cv2.erode(mask, kernel, iterations=2)\n    mask = cv2.dilate(mask, kernel, iterations=2)\n\n    contornos, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n\n    tiene_pelota = False\n\n    if len(contornos) &gt; 0:\n        c = max(contornos, key=cv2.contourArea)\n        (x, y), radio = cv2.minEnclosingCircle(c)\n\n        if radio &gt; 5:  # umbral m\u00ednimo para ruido\n            tiene_pelota = True\n\n            x = int(x)\n            y = int(y)\n            radio = int(radio)\n\n            # Guardamos \u00faltima posici\u00f3n de la pelota\n            last_ball_x = x\n            last_ball_y = y\n\n            # Dibujar pelota\n            cv2.circle(frame, (x, y), radio, (255, 0, 0), 2)\n            cv2.circle(frame, (x, y), 3, (255, 0, 0), -1)\n\n            # Dibujar l\u00edneas del centro calibrado\n            cx = int(centerX)\n            cy = int(centerY)\n            cv2.line(frame, (cx, 0), (cx, h), (0, 255, 255), 1)\n            cv2.line(frame, (0, cy), (w, cy), (0, 255, 255), 1)\n            cv2.circle(frame, (cx, cy), 5, (0, 255, 0), -1)  # centro calibrado\n\n            # Errores normalizados respecto al centro calibrado\n            errx_img = (x - cx) / (w / 2)   # derecha +, izquierda -\n            erry_img = (y - cy) / (h / 2)   # abajo +, arriba -\n\n            # Posible intercambio de ejes\n            if SWAP_AXES:\n                errx_raw = erry_img\n                erry_raw = errx_img\n            else:\n                errx_raw = errx_img\n                erry_raw = erry_img\n\n            # Invertir si hace falta (lo cambias en vivo con 'x' y 'y')\n            if INVERT_X:\n                errx_raw = -errx_raw\n            if INVERT_Y:\n                erry_raw = -erry_raw\n\n            # Mostrar errores crudos para debug\n            cv2.putText(frame, f\"Ex:{errx_raw:+.2f} Ey:{erry_raw:+.2f}\",\n                        (10, 25), cv2.FONT_HERSHEY_SIMPLEX, 0.6,\n                        (255, 255, 255), 2)\n\n            # - Control PD -\n            derx = (errx_raw - last_errx) / dt\n            dery = (erry_raw - last_erry) / dt\n\n            dxf = alpha * dxf + (1 - alpha) * derx\n            dyf = alpha * dyf + (1 - alpha) * dery\n\n            uX = KpX * errx_raw + KdX * dxf\n            uY = KpY * erry_raw + KdY * dyf\n\n            # Limitamos uX, uY a [-1,1]\n            uX = float(np.clip(uX, -1.0, 1.0))\n            uY = float(np.clip(uY, -1.0, 1.0))\n\n            # Offset de servos en grados (cada servo controla un eje)\n            servo_off_X = uX * MAX_SERVO_OFFSET_X\n            servo_off_Y = uY * MAX_SERVO_OFFSET_Y\n\n            # \u00c1ngulos l\u00f3gicos absolutos\n            ang_x = NEUT_X - servo_off_X   # SERVO eje X\n            ang_y = NEUT_Y - servo_off_Y   # SERVO eje Y\n\n            # Limitar a 0..180\n            ang_x = int(np.clip(ang_x, 0, 180))\n            ang_y = int(np.clip(ang_y, 0, 180))\n\n            cv2.putText(frame,\n                        f\"X:{ang_x}  Y:{ang_y}\",\n                        (10, 50), cv2.FONT_HERSHEY_SIMPLEX, 0.6,\n                        (0, 255, 255), 2)\n\n            # Enviar comando ANG: (2 servos: X,Y) \n            if send_allowed:\n                try:\n                    cmd = f\"ANG:{ang_x},{ang_y}\\n\"\n                    sock.send(cmd.encode())\n                    # print(\"CMD -&gt;\", cmd.strip())\n                    last_cmd_time = now\n                except Exception as e:\n                    print(\" Error al enviar ANG:\", e)\n\n            last_errx = errx_raw\n            last_erry = erry_raw\n            last_time = now\n\n    if not tiene_pelota:\n        cv2.putText(frame, \"PELOTA NO DETECTADA\", (10, 25),\n                    cv2.FONT_HERSHEY_SIMPLEX, 0.7,\n                    (0, 0, 255), 2)\n        # Si pierdes la pelota, manda NEUTROS \u2192 180\u00b0 en los 2 servos\n        if send_allowed:\n            try:\n                cmd_lost = f\"ANG:{NEUT_X},{NEUT_Y}\\n\"\n                sock.send(cmd_lost.encode())\n                last_cmd_time = now\n                # print(\"CMD LOST-NEUTRO -&gt;\", cmd_lost.strip())\n            except Exception as e:\n                print(\" Error al enviar NEUTRO (sin pelota):\", e)\n\n    # Mostrar estado de flags\n    status = f\"invX:{INVERT_X}  invY:{INVERT_Y}  swap:{SWAP_AXES}  TEST:{TEST_MODE}\"\n    cv2.putText(frame, status, (10, h - 10),\n                cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 255, 0), 2)\n\n    cv2.imshow(\"Ball Balancing Control\", frame)\n    cv2.imshow(\"Mascara\", mask)\n\n    key = cv2.waitKey(1) &amp; 0xFF\n    if key == ord('q'):\n        break\n    elif key == ord('c'):\n        # Tecla 'c' para centrar manualmente (180\u00b0 en ambos)\n        try:\n            cmd_c = f\"ANG:{NEUT_X},{NEUT_Y}\\n\"\n            sock.send(cmd_c.encode())\n            last_cmd_time = time.time()\n            print(\"Comando CENTRO 180\u00b0 enviado.\")\n        except Exception as e:\n            print(\" Error al enviar CENTRO:\", e)\n    elif key == ord('x'):\n        INVERT_X = not INVERT_X\n        print(\"INVERT_X -&gt;\", INVERT_X)\n    elif key == ord('y'):\n        INVERT_Y = not INVERT_Y\n        print(\"INVERT_Y -&gt;\", INVERT_Y)\n    elif key == ord('s'):\n        SWAP_AXES = not SWAP_AXES\n        print(\"SWAP_AXES -&gt;\", SWAP_AXES)\n    elif key == ord('b'):\n        # Calibrar centro con la pelota en el centro f\u00edsico\n        if last_ball_x is not None and last_ball_y is not None:\n            centerX = last_ball_x\n            centerY = last_ball_y\n            print(f\"Centro calibrado en ({centerX}, {centerY})\")\n\nvideo.release()\nsock.close()\ncv2.destroyAllWindows()\n</code></pre> <p>El c\u00f3digo de Arduno implementado en el ESP32 tiene como prop\u00f3sito recibir, interpretar y ejecutar los comandos de control enviados desde el programa en Python, con el fin de mover los servomotores que inclinan la plataforma del sistema Ball and Plate. Su funci\u00f3n principal es actuar como la interfaz f\u00edsica entre el algoritmo de control y el mecanismo real.</p> <p>A trav\u00e9s del m\u00f3dulo Bluetooth interno del ESP32, el microcontrolador recibe continuamente mensajes en el formato \u201cANG:x,y\u201d, los cuales representan los \u00e1ngulos l\u00f3gicos de los servomotores para los ejes X y Y. Una vez recibido un comando, el programa lo analiza, lo valida y lo convierte en un \u00e1ngulo f\u00edsico real, tomando en cuenta la inversi\u00f3n mec\u00e1nica de los servos para que los movimientos correspondan correctamente a las direcciones generadas por el controlador.</p> <p>El sistema incorpora una rampa de movimiento suave, dise\u00f1ada para evitar saltos bruscos que puedan generar vibraciones o inestabilidad en la plataforma. Esta rampa ajusta gradualmente la posici\u00f3n de los servos hasta alcanzar el \u00e1ngulo objetivo, mejorando el desempe\u00f1o din\u00e1mico y reduciendo el desgaste mec\u00e1nico. Asimismo, el c\u00f3digo implementa un mecanismo de seguridad que devuelve autom\u00e1ticamente los servos a su posici\u00f3n neutra si no se recibe ning\u00fan comando en un tiempo determinado.</p> <pre><code>#include &lt;Arduino.h&gt;\n#include \"BluetoothSerial.h\"\nBluetoothSerial SerialBT;\n// Buffer para lectura BT no bloqueante \nString btBuffer;\n// Pines de los servos\n// SERVO_X controla eje X\n// SERVO_Y controla eje Y\n#define SERVO_X   21\n#define SERVO_Y   19\n// PWM\nconst uint32_t FREQ_HZ = 50;\nconst uint8_t  RES_BITS = 12;\nconst uint16_t DUTY_MIN = 205;   // ~1.0 ms\nconst uint16_t DUTY_MAX = 410;   // ~2.0 ms\n// Convierte grados f\u00edsicos 0..180 a duty\nuint16_t dutyFromDeg(int deg){\n  deg = constrain(deg,0,180);\n  return map(deg,0,180,DUTY_MIN,DUTY_MAX);\n}\n// Convierte de \u00e1ngulo l\u00f3gico (0..180) a f\u00edsico (invertido)\nint logicalToPhysical(int logicalDeg){\n  logicalDeg = constrain(logicalDeg, 0, 180);\n  // 0 l\u00f3gico -&gt; 180 f\u00edsico, 180 l\u00f3gico \u2192 0 f\u00edsico\n  return 180 - logicalDeg;\n}\n// Escribe usando grados l\u00f3gicos\nvoid writeServoLogical(int pin, int logicalDeg){\n  int fisico = logicalToPhysical(logicalDeg);\n  ledcWrite(pin, dutyFromDeg(fisico));\n}\n// Configurar servo con \u00e1ngulo l\u00f3gico inicial\nvoid configServo(int pin, int initialLogical){\n  pinMode(pin,OUTPUT);\n  ledcAttach(pin,FREQ_HZ,RES_BITS);   // usa el pin como canal\n  writeServoLogical(pin,initialLogical);\n}\n//  Rango y rampa \nconst int LIM_MIN = 0;\nconst int LIM_MAX = 180;\nconst int PASO_RAMPA = 45;          // tama\u00f1o de paso en rampa\nconst uint32_t DT_RAMP_MS = 2;\nconst uint32_t TIMEOUT_MS = 700;\n// Estado en grados L\u00d3GICOS (arrancan en 180)\nint posX = 180;\nint posY = 180;\nint tgtX = 180;\nint tgtY = 180;\nuint32_t tPrevRamp = 0;\nuint32_t tLastCmd  = 0;\n// Rampa suave hacia el objetivo\nvoid aplicarRampa(){\n  uint32_t now = millis();\n  if(now - tPrevRamp &lt; DT_RAMP_MS) return;\n  tPrevRamp = now;\n  auto go = [&amp;](int actual,int target){\n    if(actual &lt; target) return min(actual + PASO_RAMPA, target);\n    if(actual &gt; target) return max(actual - PASO_RAMPA, target);\n    return actual;\n  };\n  posX = go(posX, tgtX);\n  posY = go(posY, tgtY);\n  // Escribimos usando grados L\u00d3GICOS, se invierten adentro\n  writeServoLogical(SERVO_X, posX);\n  writeServoLogical(SERVO_Y, posY);\n}\n//  \"ANG:x,y\"\nbool parseAngulos(const String &amp;msg, int &amp;aX, int &amp;aY){\n  if (!msg.startsWith(\"ANG:\")) return false;\n  String data = msg.substring(4);  // despu\u00e9s de \"ANG:\"\n  int c1 = data.indexOf(',');\n  if (c1 &lt; 0) return false;\n  String sX = data.substring(0, c1);\n  String sY = data.substring(c1 + 1);\n  sX.trim();\n  sY.trim();\n  aX = sX.toInt();\n  aY = sY.toInt();\n  return true;\n}\n// SETUP \nvoid setup(){\n  Serial.begin(115200);\n  SerialBT.begin(\"fina\");\n  // Ambos servos arrancan en 180 l\u00f3gico\n  configServo(SERVO_X, posX);\n  configServo(SERVO_Y, posY);\n  Serial.println(\"ESP32 listo (2 servos X/Y, neutro 180\u00b0)\");\n  tLastCmd = millis();\n}\n// LOOP \nvoid loop(){\n  // Lectura Bluetooth no bloqueante \n  while (SerialBT.available()) {\n    char c = (char)SerialBT.read();\n    if (c == '\\n') {\n      // Tenemos una l\u00ednea completa en btBuffer\n      String msg = btBuffer;\n      btBuffer = \"\";        // limpiar para el siguiente mensaje\n      msg.trim();\n      if (msg.length() &gt; 0) {\n        tLastCmd = millis();\n        if (msg == \"ZERO\") {\n          // Todos a 0 l\u00f3gico (180 f\u00edsico por inversi\u00f3n)\n          tgtX = 0;\n          tgtY = 0;\n          Serial.println(\"Comando ZERO: X/Y \u2192 0 l\u00f3gico (180 f\u00edsico)\");\n        } else {\n          int aX, aY;\n          if (parseAngulos(msg, aX, aY)) {\n            tgtX = constrain(aX, LIM_MIN, LIM_MAX);\n            tgtY = constrain(aY, LIM_MIN, LIM_MAX);\n            Serial.printf(\"ANG -&gt; X:%d  Y:%d\\n\", tgtX, tgtY);\n          } else {\n            Serial.print(\"Comando desconocido: \");\n            Serial.println(msg);\n          }\n        }\n      }\n    } else if (c != '\\r') {\n      // Acumulamos caracteres, ignorando CR\n      btBuffer += c;\n    }\n  }\n  // Si pasa mucho tiempo sin recibir comandos, vuelve al neutro 180\n  if(millis() - tLastCmd &gt; TIMEOUT_MS){\n    tgtX = 180;\n    tgtY = 180;\n  }\n  aplicarRampa();\n  delay(1);\n}\n</code></pre>"},{"location":"Ball_and_plate_system/#funcionamiento-de-la-base","title":"Funcionamiento de la base","text":"<p>La primera imagen presentada es la imagen de la camara siendo ejecutada y como captura la plataforma y la pelota en ella.</p> <p></p> <p>Mientas que la segunda imagen es la imagen de la plataforma completa junto con el circuito y la pelota en ella.</p> <p></p> <p>Y para finalizar, subimos a youtube un video con los resultados del mecanismo funionando correctamente.</p> <p>Link: youtube.com/watch?si=ySMpmDCWlPXWW_h-&amp;v=5i9Qri7ijuo&amp;feature=youtu.be</p>"},{"location":"PrimerProyecto/","title":"Primer Proyecto","text":""},{"location":"PrimerProyecto/#nombre-del-proyecto-electronica-101","title":"Nombre del proyecto: Electronica 101","text":""},{"location":"PrimerProyecto/#autores","title":"Autores","text":"<ul> <li>Barrientos Miguel Leonardo</li> <li>Zerme\u00f1o Cervantes Rodrigo</li> </ul>"},{"location":"PrimerProyecto/#asignatura-introduccion-a-la-mecatronica","title":"Asignatura: Introducci\u00f3n a la Mecatronica","text":""},{"location":"PrimerProyecto/#fecha-5-de-septiembre-del-2025","title":"Fecha: 5 de Septiembre del 2025","text":""},{"location":"PrimerProyecto/#descripcion","title":"Descripci\u00f3n","text":"<p>Con los componentes electronicos que teniamos (Protoboard, jumpers, resistencias, etc.) tenemos que lograr que un foco led se encienda y se apague automaticamente con un lapso determinado de tiempo</p>"},{"location":"PrimerProyecto/#objetivos","title":"Objetivos","text":""},{"location":"PrimerProyecto/#general","title":"General","text":"<p>En este primer proyecto realizado en la materia de \"Introducci\u00f3n a la Mecatronica\" pretendiamos lograr realizar un circuito junto con un \"temporizador 555\"  para que un led se encendiara y apagara de manera automatica en un lapso de 3 a 5 segundos, esto al \"retrasar\" la velocidad con la que se encendia y se apagaba el foco led empleando tanto resistenias como capacitores de diferentes capacidades.</p>"},{"location":"PrimerProyecto/#especificos","title":"Especificos","text":"<p>-OE1: como un objetivo especifico personal de ambos, queriamos lograr comprender mejor todo en cuanto al tema de electronica debido a que anteriormente no habiamos tenido expericencia con esto, al menos no en la preparatoria, por lo que de manera personal, ambos buscabamos poder lograr ampliar nuestros conocimientos en cuanto a este tema.</p>"},{"location":"PrimerProyecto/#alcance-y-exclusiones","title":"Alcance y Exclusiones","text":"<p>-Incluye: calculos realizados por la calculadora \"DigiKey\" con los materiales que teniamos disponibles para realizar el trabajo y fotos de el foco led tanto encendido como apagado.</p> <p>-No Incluye: foto especifica de los materiales ocupados, sin embargo es posible visualizarlos en las fotograf\u00edas.</p>"},{"location":"PrimerProyecto/#procedimiento","title":"Procedimiento","text":"<p>Lo primero que realizamos fue revisas los diferentes valores de los capacitores y de las resistencias que teneiamos disponibles, en ese momento para realizar el trabajo y de esta manera, con la calculadora poder comprobar el tiempo en que se retrasaba la velocidad de encendido del led.</p> <p>Nosotros al elegir ocupar las dos resistencias de 200 kiloohms y el capacitos de 22 microfaradios, el tiempo alto que marcaba era de 6.0984 segundos, mientras que el tiempo bajo era de 3.0492 segundos. Si bien el tiempo alto era mayor al permitido, esto era lo m\u00e1s cercano que podiamos realizar con lo que teniamos a la mano, adem\u00e1s de que si se logro mantener en el intervalo de tiempo indicado sin sobrepasar los 5 segundos.</p> <p></p> <p>Foto de la calculadora \"DigiKey\" con los valores ya mencionados</p> <p>Si bien al inicio no lograbamos obtener buenos resultados incluso un poco despues de terminada la clase, despues de desconectar todo y volver a conectarlo paso a paso y de manera m\u00e1s calmada, fue que logramos que nuestro trabajo resultara funcional y que el led se encendiera y se apagara continuamente en un intervalo de entre 3 y 5 segundos.</p> <p></p> <p>Captura de pantalla del video en el momento en que el foco estaba apagado.</p> <p></p> <p>Captura de pantalla del video en el momento en que el foco esta encendido.</p>"},{"location":"SegundoProyecto/","title":"Segundo Proyecto","text":""},{"location":"SegundoProyecto/#nombre-del-proyecto-mcu-101","title":"Nombre del proyecto: MCU 101","text":""},{"location":"SegundoProyecto/#autores","title":"Autores","text":"<ul> <li>Barrientos Miguel Leonardo</li> <li>Zerme\u00f1o Cervantes Rodrigo</li> </ul>"},{"location":"SegundoProyecto/#asignatura-introduccion-a-la-mecatronica","title":"Asignatura: Introducci\u00f3n a la Mecatronica","text":""},{"location":"SegundoProyecto/#fecha-12-de-septiembre-del-2025","title":"Fecha: 12 de Septiembre del 2025","text":""},{"location":"SegundoProyecto/#descripcion","title":"Descripci\u00f3n","text":"<p>Con los componentes electronicos que teniamos (Arduino ,Jumpers,Protoboar,etc)tenemos que lograr que un foco led se encienda y se apague programando nuestro arduino desde la computadora.</p>"},{"location":"SegundoProyecto/#objetivos","title":"Objetivos","text":""},{"location":"SegundoProyecto/#general","title":"General","text":"<p>En este segundo proyecto  de \"Introducci\u00f3n a la Mecatronica\" pretendiamos lograr realizar un circuito programando  un \"Arduino\"  para que un led se encendiara y apagara dependiendo de las indicaciones del codigo que dise\u00f1amos durante la clase.</p>"},{"location":"SegundoProyecto/#especificos","title":"Especificos","text":"<p>-OE1:Como objetivo especifico,ambos buscamos tener un desempe\u00f1o superior al del primer proyecto,nuevamente tuvimos la mentalidad del poder ampliar nuestros conocimientos para tener un mejor desempe\u00f1o en los proyectos que realizaremos en un futuro.</p>"},{"location":"SegundoProyecto/#alcance-y-exclusiones","title":"Alcance y Exclusiones","text":"<p>-Incluye: Todos los codigos que utilizamos para cada uno de los circuitos que realizamos junto a fotografias de cada circuito</p> <p>-No Incluye: foto especifica de los materiales ocupados, sin embargo es posible visualizarlos en las fotograf\u00edas.</p>"},{"location":"SegundoProyecto/#procedimiento-1","title":"Procedimiento 1","text":"<p>Lo primero que hicimos fue revisar todo nuestro material  de de trabajo y con una breve introducion de como utilizar nuestro arduino realizamos un circuito el cual estaria conectado a nuestro principal material de trabajo el \"Arduino\",acto siguiente realizamos un codigo el cual su principal funcion era encender y apagar nuestro led con un peque\u00f1o \"delay\" para lograr precibir  el momento en del encendido y apagado del led</p>"},{"location":"SegundoProyecto/#codigo-1","title":"Codigo 1:","text":"<pre><code>const int led=33; // Puerto del arduino al que esta conectado el led\n\nvoid setup() {\n\n  Serial.begin(115200);\n\n  pinMode(led, OUTPUT);\n\n}\n\nvoid loop() {  // Repeticion constante del encendido y apagado\n\n     digitalWrite(led,1); //Encendido\n\n     delay(1000); // Retraso del encendido y apagado del led\n\n     digitalWrite(led,0); //Apagado\n\n     delay(1000);\n\n  }\n</code></pre> <p>Captura de pantalla del video en el momento en que el foco estaba apagado.</p> <p></p> <p>Captura de pantalla del video en el momento en que el foco esta encendido.</p>"},{"location":"SegundoProyecto/#procedimiento-2","title":"Procedimiento 2","text":"<p>Tomando como base nuestro primer codigo y circuito, realizamos unos cambios en ambas cosas.Primero le agregamos un boton al circuito con el cual buscabamos encender y apagar el led cuando lo presionaramos,este lo agregamos en el puerto \"34\" de nuestro arduino.Entonces para que el circuito funcionara tuvimos que agregar otra constante al codigo,agregamos una entrada y pusimos condicionales para cuando presionaramos el boton el led se encendiera y cuando no este permaneciera apagado.</p>"},{"location":"SegundoProyecto/#codigo-2","title":"Codigo 2:","text":"<pre><code>const int led=33; // LED\n\nconst int btn=34; // BOTON\n\nvoid setup() {\n\n  Serial.begin(115200);\n\n  pinMode(led, OUTPUT); // SALIDA\n\n  pinMode(btn, INPUT); // ENTRADA\n\n\n}\n\nvoid loop() {\n\n  int estado = digitalRead(btn); \n\n  if(estado == 1){\n\n     digitalWrite(led,1);  // PRENDIDO\n  }\n\n  else {\n\n    digitalWrite(led,0); // APAGADO\n\n  }\n\n}\n</code></pre> <p>Captura de pantalla del video en el momento en que el boton no estaba presionado y el led estaba apagado</p> <p></p> <p>Captura de pantalla del video en el momento en el que el boton estaba presionado y el led estaba encendido</p>"},{"location":"SegundoProyecto/#procedimiento-3","title":"Procedimiento 3","text":"<p>Para este tercer ejercicio utilizamos la app \"Serial Bluetooth Terminal\" la cual se conecta al Arduino via Bluetooth y con la terminal que se encuentra en la app podemos mandar se\u00f1ales al arduino para que encienda o apague el led con el codigo que programamos.</p> <p>Tomamos como base el segundo codigo que realizamos y le hicimos algunas modificaciones, agregamos la libreria #include \"BluetoothSerial.h\",quitamos la constante del boton y remplazamos su entrada por nuestra conexi\u00f3n Bluetooth la cual la llamamos \"LR23\", despues remplazamos nuestras condicionales por unas que nos sirvieran con la app y como condici\u00f3n pusimos que al mandar el mensaje \"Prende\" en la terminal de la app el LED se prenderia, en caso de recibir otro mensaje este se apaga o permanece apagado.</p>"},{"location":"SegundoProyecto/#codigo-3","title":"Codigo 3:","text":"<pre><code>\"#\"include \"BluetoothSerial.h\"\n\nBluetoothSerial SerialBT;\n\nconst int led=33;\n\n\nvoid setup() {\n\n  Serial.begin(115200);\n\n  SerialBT.begin(\"LR23\"); // Dipositivo bluetooth\n\n  pinMode(led, OUTPUT);\n\n}\n\nvoid loop() {\n\n  if(SerialBT.available()){\n\n    String mensaje = SerialBT.readString();\n\n    Serial.println(\"Recibido: \" + mensaje);\n\n    if(mensaje == \"Prende\"){\n\n     digitalWrite(led,1);\n\n    }\n\n    else {\n\n      digitalWrite(led,0);\n    }\n\n  }\n\n  delay(100);\n\n }\n</code></pre> <p>Captura de pantalla del video en el momento que se manda el mensaje \"Prende\" en la terminan y el Led prende (El mensaje \"Prende\" se mando dos veces y el led permanecio prendido)</p> <p></p> <p>Captura de pantalla del video en el momento que se manda el mensaje \"a\" en la terminan y el Led se apaga</p>"},{"location":"TercerProyecto/","title":"Tercer Proyecto","text":""},{"location":"TercerProyecto/#nombre-del-proyectocontrol-de-motor-dc","title":"Nombre del proyecto:Control de motor DC","text":""},{"location":"TercerProyecto/#autores","title":"Autores","text":"<ul> <li>Barrientos Miguel Leonardo</li> <li>Zerme\u00f1o Cervantes Rodrigo</li> </ul>"},{"location":"TercerProyecto/#asignatura-introduccion-a-la-mecatronica","title":"Asignatura: Introducci\u00f3n a la Mecatronica","text":""},{"location":"TercerProyecto/#fecha-19-de-septiembre-del-2025","title":"Fecha: 19 de Septiembre del 2025","text":""},{"location":"TercerProyecto/#descripcion","title":"Descripci\u00f3n","text":"<p>En este tercer proyecto de la materia Introducci\u00f3n a la Mecatr\u00f3nica, nuestro objetivo fue realizar la conexi\u00f3n y programaci\u00f3n de un motor DC para lograr su encendido, apagado y control de velocidad utilizando un Arduino/ESP32. Usamos los pines digitales y la funci\u00f3n <code>ledcWrite()</code> para variar la velocidad del motor mediante la t\u00e9cnica de modulaci\u00f3n por ancho de pulso (PWM).</p>"},{"location":"TercerProyecto/#objetivos","title":"Objetivos","text":""},{"location":"TercerProyecto/#general","title":"General","text":"<p>Aprender a controlar un motor DC utilizando un microcontrolador, comprendiendo el funcionamiento de los pines de salida y el control de velocidad por PWM.</p>"},{"location":"TercerProyecto/#especificos","title":"Especificos","text":"<ul> <li>Programar el encendido y cambio de giro del motor.  </li> <li>Implementar el control de velocidad mediante la funci\u00f3n <code>ledcWrite()</code>.  </li> <li>Comprender la relaci\u00f3n entre frecuencia, ciclo de trabajo y velocidad del motor.</li> </ul>"},{"location":"TercerProyecto/#alcance-y-exclusiones","title":"Alcance y Exclusiones","text":"<p>-Incluye:</p> <ul> <li>Conexi\u00f3n del motor DC a trav\u00e9s del driver y pines de salida del Arduino/ESP32.  </li> <li>C\u00f3digo para encendido, apagado y cambio de giro.  </li> <li>C\u00f3digo con control progresivo de velocidad.  </li> </ul> <p>-No Incluye: </p>"},{"location":"TercerProyecto/#procedimiento","title":"Procedimiento","text":"<p>Primero identificamos los pines de salida del microcontrolador y realizamos las conexiones correspondientes del motor. Una vez conectado, programamos un c\u00f3digo sencillo que permitiera encender el motor en una direcci\u00f3n, detenerlo y hacerlo girar en sentido contrario con intervalos de tres segundos entre cada encendido. Este fue nuestro primer c\u00f3digo funcional:</p>"},{"location":"TercerProyecto/#codigo-1","title":"C\u00f3digo 1","text":"<pre><code>#define in1 32\n#define in2 33\n\nvoid setup() {\n  pinMode(in1, OUTPUT);\n  pinMode(in2, OUTPUT);\n}\n\nvoid loop() {\n  digitalWrite(in1,1);\n  digitalWrite(in2,0);\n  delay(3000);\n  digitalWrite(in1,0);\n  digitalWrite(in2,0);\n  delay(3000);\n  digitalWrite(in1,0);\n  digitalWrite(in2,1);\n  delay(3000);\n}\n</code></pre> <p>Como segunda parte de este proyecto, en base a lo anteriormente realizado teniamos que programar el motor de manera que pudiesemos controlar su velocidad y que este aumentara y disminuyera gradualmente su velocidad en lugar de detenerse o empezar a avanzar repentinamente. Esto debido a que traducido a un motor real, si llegase a suceder, podria ocurrir una perdida de control o incluso un degaste innecesario en el mecanismo.</p> <p>A continuaci\u00f3n el segundo codigo que ocupamos para esta segunda parte del proyecto:</p>"},{"location":"TercerProyecto/#codigo-2","title":"C\u00f3digo 2","text":"<pre><code>pinMode(in1, OUTPUT);\n  pinMode(in2, OUTPUT);\n  //Control de velocidad\n  ledcAttachChannel(pwm,1000,8,0); //pin,frecuencia,bits,canal   //config\n\n}\n\nvoid loop() {\n\n  for(vel=0; vel&lt;=256;vel++){\n  ledcWrite(pwm,vel);\n  digitalWrite(in1,1);\n  digitalWrite(in2,0);\n  delay(10);\n  }\n\n  for(vel=256;vel&gt;=0;vel--){\n  digitalWrite(in1,1);\n  digitalWrite(in2,0);\n  delay(10);\n\n\n  }\n\n\n\n\n}\n</code></pre> <p>Lo siguiente son imagenes del motor utilizado asi como de este conectado a un puente H que conectaba con el Arduino/ESP32 para poder recibir la programaci\u00f3n de los c\u00f3digos previamente vistos</p> <p></p> <p>Foto del motor utilizado en cuesti\u00f3n para este proyecto</p> <p></p> <p>Foto del motor utilizado conectado al puente H interconectado con el Arduino/ESP32</p>"},{"location":"comandos/","title":"Encabezados","text":"<pre><code># T\u00edtulo H1\n## T\u00edtulo H2\n### T\u00edtulo H3\n</code></pre>"},{"location":"comandos/#titulo-h1","title":"T\u00edtulo H1","text":""},{"location":"comandos/#titulo-h2","title":"T\u00edtulo H2","text":""},{"location":"comandos/#titulo-h3","title":"T\u00edtulo H3","text":""},{"location":"comandos/#enfasis-y-codigo-en-linea","title":"\u00c9nfasis y c\u00f3digo en l\u00ednea","text":"<pre><code>**negritas**, *cursivas*, ~~tachado~~, `c\u00f3digo en l\u00ednea`\n</code></pre> <p>negritas, cursivas, ~~tachado~~, <code>c\u00f3digo en l\u00ednea</code></p>"},{"location":"comandos/#citas-blockquote","title":"Citas (blockquote)","text":"<pre><code>&gt; Esta es una cita destacada.\n&gt; Puede tener m\u00faltiples l\u00edneas.\n</code></pre> <p>Esta es una cita destacada. Puede tener m\u00faltiples l\u00edneas.</p>"},{"location":"comandos/#enlaces","title":"Enlaces","text":"<pre><code>[Enlace directo](https://www.iberopuebla.mx/)\n\n[Texto del enlace de referencia][doc-ref]\n\n[doc-ref]: https://www.iberopuebla.mx//docs \"T\u00edtulo opcional\"\n</code></pre> <p>Enlace directo</p> <p>Texto del enlace de referencia</p>"},{"location":"comandos/#listas-vinetas-numeradas-y-de-tareas","title":"Listas: vi\u00f1etas, numeradas y de tareas","text":"<pre><code>- Item A\n    * Subitem A.1\n    * Subitem A.2\n- Item B\n    - Subitem B.1\n    - Subitem B.2\n\n1.  Paso 1\n    1.  Paso 1.1\n    2.  Paso 1.2\n        1.  Paso 1.2.1\n        2.  Paso 1.2.2\n\n- [x] Hecho\n- [ ] Pendiente\n</code></pre> <ul> <li>Item A<ul> <li>Subitem A.1</li> <li>Subitem A.2</li> </ul> </li> <li>Item B<ul> <li>Subitem B.1</li> <li>Subitem B.2</li> </ul> </li> </ul> <ol> <li> <p>Paso 1</p> <ol> <li>Paso 1.1</li> <li>Paso 1.2<ol> <li>Paso 1.2.1</li> <li>Paso 1.2.2</li> </ol> </li> </ol> </li> <li> <p> Hecho</p> </li> <li> Pendiente</li> </ol>"},{"location":"comandos/#tablas","title":"Tablas","text":"<pre><code>| Componente | Cant. | Nota        |\n|-----------:|:-----:|-------------|\n| Sensor X   | 2     | I2C         |\n| MCU Y      | 1     | WiFi/BLE    |\n</code></pre> Componente Cant. Nota Sensor X 2 I2C MCU Y 1 WiFi/BLE"},{"location":"comandos/#imagenes","title":"Im\u00e1genes","text":"<pre><code>![Diagrama del sistema](recursos/imgs/ibero.jpeg)\n\n&lt;!-- Control de tama\u00f1o usando HTML (cuando se requiera) --&gt;\n&lt;img src=\"../recursos/imgs/ibero.jpeg\" alt=\"Diagrama del sistema\" width=\"420\"&gt;\n</code></pre>"},{"location":"comandos/#pdfs-enlace-y-embebido","title":"PDFs (enlace y embebido)","text":"<pre><code>[Descargar especificaci\u00f3n (PDF)](recursos/archivos/Calendario.pdf)\n\n&lt;!-- Embed (requiere navegador compatible) --&gt;\n&lt;object data=\"recursos/archivos/Calendario.pdf\" type=\"application/pdf\" width=\"100%\" height=\"600\"&gt;\n  &lt;p&gt;No se pudo mostrar el PDF. &lt;a href=\"../recursos/archivos/Calendario.pdf\"&gt;Descargar&lt;/a&gt;&lt;/p&gt;\n&lt;/object&gt;\n</code></pre> <p>Descargar especificaci\u00f3n (PDF)</p>"},{"location":"comandos/#admonitions-material","title":"Admonitions (Material)","text":"<pre><code>!!! note \"Nota\"\n    Esto es una nota informativa.\n\n!!! tip \"Sugerencia\"\n    Un consejo breve para el usuario.\n\n!!! warning \"Advertencia\"\n    Precauciones o riesgos a considerar.\n\n??? info \"M\u00e1s informaci\u00f3n (colapsable)\"\n    Contenido adicional que se puede expandir.\n</code></pre> <p>Nota</p> <p>Esto es una nota informativa.</p> <p>Sugerencia</p> <p>Un consejo breve para el usuario.</p> <p>Advertencia</p> <p>Precauciones o riesgos a considerar.</p> M\u00e1s informaci\u00f3n (colapsable) <p>Contenido adicional que se puede expandir.</p>"},{"location":"comandos/#codigo-con-resaltado","title":"C\u00f3digo con resaltado","text":"<p><pre><code>```python\ndef medir(canal: int) -&gt; dict:\n    # Simulaci\u00f3n de lectura\n    return {\"canal\": canal, \"valor\": 523, \"unidad\": \"mV\"}\n\nprint(medir(1))\n</code></pre> <pre><code>```python\ndef medir(canal: int) -&gt; dict:\n    # Simulaci\u00f3n de lectura\n    return {\"canal\": canal, \"valor\": 523, \"unidad\": \"mV\"}\n\nprint(medir(1))\n</code></pre></p>"},{"location":"comandos/#separador-horizontal","title":"Separador horizontal","text":"<pre><code>---\n</code></pre>"},{"location":"comandos/#listas-anidadas-con-codigo-y-notas","title":"Listas anidadas con c\u00f3digo y notas","text":"<pre><code>- **M\u00f3dulo A**\n  - Funci\u00f3n: `procesar()`\n  - Entrada:\n    - `signal` (float)\n    - `freq` (Hz)\n  - Salida:\n    - JSON con `valor`, `unidad`\n  - !!! note\n        Documenta rangos v\u00e1lidos y casos borde.\n</code></pre> <ul> <li>M\u00f3dulo A</li> <li>Funci\u00f3n: <code>procesar()</code></li> <li>Entrada:<ul> <li><code>signal</code> (float)</li> <li><code>freq</code> (Hz)</li> </ul> </li> <li>Salida:<ul> <li>JSON con <code>valor</code>, <code>unidad</code></li> </ul> </li> <li> <p>Note</p> <pre><code>Documenta rangos v\u00e1lidos y casos borde.\n</code></pre> </li> </ul>"},{"location":"comandos/#bloques-de-cita-con-codigo-pseudo-logs","title":"Bloques de cita con c\u00f3digo (pseudo-logs)","text":"<pre><code>&gt; **Log:**\n&gt; ```\n&gt; [12:00:00] Init OK\n&gt; [12:00:01] Conectando a I2C...\n&gt; [12:00:02] Lectura: 523 mV\n&gt; ```\n</code></pre> <p>Log: <pre><code>[12:00:00] Init OK\n[12:00:01] Conectando a I2C...\n[12:00:02] Lectura: 523 mV\n</code></pre></p>"},{"location":"ejemplo/","title":"\ud83d\udcda Ejemplo de Documentaci\u00f3n del Proyecto","text":"<p>Plantilla gen\u00e9rica para documentar proyectos acad\u00e9micos o de ingenier\u00eda. Copia y adapta las secciones seg\u00fan tu necesidad.</p>"},{"location":"ejemplo/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Mi Proyecto </li> <li>Equipo / Autor(es): Nombre(s) </li> <li>Curso / Asignatura: Nombre del curso </li> <li>Fecha: DD/MM/AAAA </li> <li>Descripci\u00f3n breve: Una o dos l\u00edneas que expliquen qu\u00e9 hace y por qu\u00e9.</li> </ul> <p>Consejo</p> <p>Mant\u00e9n este resumen corto (m\u00e1x. 5 l\u00edneas). Lo dem\u00e1s va en secciones espec\u00edficas.</p>"},{"location":"ejemplo/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>General: Qu\u00e9 se pretende lograr en t\u00e9rminos amplios.</li> <li>Espec\u00edficos:</li> <li>OE1\u2026</li> <li>OE2\u2026</li> <li>OE3\u2026</li> </ul>"},{"location":"ejemplo/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<ul> <li>Incluye: Qu\u00e9 funcionalidades/entregables s\u00ed est\u00e1n en el proyecto.</li> <li>No incluye: Qu\u00e9 queda fuera para evitar malentendidos.</li> </ul>"},{"location":"ejemplo/#4-requisitos","title":"4) Requisitos","text":"<p>Software - SO compatible (Windows/Linux/macOS) - Python 3.x / Node 18+ / Arduino IDE / etc. - Dependencias (p. ej., pip/requirements, npm packages)</p> <p>Hardware (si aplica) - MCU / Sensores / Actuadores / Fuente de poder - Herramientas (mult\u00edmetro, caut\u00edn, etc.)</p> <p>Conocimientos previos - Programaci\u00f3n b\u00e1sica en X - Electr\u00f3nica b\u00e1sica - Git/GitHub</p>"},{"location":"ejemplo/#5-instalacion","title":"5) Instalaci\u00f3n","text":"<pre><code># 1) Clonar\ngit clone https://github.com/&lt;usuario&gt;/&lt;repo&gt;.git\ncd &lt;repo&gt;\n\n# 2) (Opcional) Crear entorno virtual\npython -m venv .venv\n# macOS/Linux\nsource .venv/bin/activate\n# Windows (PowerShell)\n.venv\\Scripts\\Activate.ps1\n\n# 3) Instalar dependencias (ejemplos)\npip install -r requirements.txt\n# o, si es Node:\nnpm install\n</code></pre>"},{"location":"gitcmds/","title":"\ud83d\ude80 Comandos b\u00e1sicos de Git (primeros pasos)","text":"<p>En este curso solo usaremos los comandos esenciales de Git para trabajar con repositorios.</p>"},{"location":"gitcmds/#1-clonar-un-repositorio","title":"1. Clonar un repositorio","text":"<p>Copia un proyecto de GitHub a tu computadora.</p> <pre><code>git clone https://github.com/usuario/repositorio.git\n</code></pre>"},{"location":"gitcmds/#2-verificar-cambios","title":"2. Verificar cambios","text":"<p>Muestra qu\u00e9 archivos has modificado o agregado.</p> <pre><code>git status\n</code></pre>"},{"location":"gitcmds/#3-preparar-cambios","title":"3. Preparar cambios","text":"<p>Agrega archivos para guardarlos en el pr\u00f3ximo commit.</p> <pre><code>git add archivo.txt\ngit add .   # agrega todos los archivos modificados\n</code></pre>"},{"location":"gitcmds/#4-guardar-cambios-commit","title":"4. Guardar cambios (commit)","text":"<p>Guarda tus cambios con un mensaje descriptivo.</p> <pre><code>git commit -m \"Descripci\u00f3n breve de los cambios\"\n</code></pre>"},{"location":"gitcmds/#5-subir-cambios-al-repositorio-push","title":"5. Subir cambios al repositorio (push)","text":"<p>Env\u00eda tus commits locales al repositorio en GitHub.</p> <pre><code>git push origin main\n</code></pre>"},{"location":"gitcmds/#6-traer-cambios-del-remoto-pull","title":"6. Traer cambios del remoto (pull)","text":"<p>Actualiza tu proyecto con los \u00faltimos cambios de GitHub.</p> <pre><code>git pull origin main\n</code></pre>"},{"location":"gitcmds/#flujo-tipico-de-trabajo","title":"Flujo t\u00edpico de trabajo","text":"<ol> <li> <p>Traer cambios del remoto <pre><code>git pull origin main\n</code></pre></p> </li> <li> <p>Editar tus archivos de proyecto.</p> </li> <li> <p>Preparar los cambios <pre><code>git add .\n</code></pre></p> </li> <li> <p>Guardar los cambios <pre><code>git commit -m \"Mensaje descriptivo\"\n</code></pre></p> </li> <li> <p>Enviar los cambios al remoto <pre><code>git push origin main\n</code></pre></p> </li> </ol> <p>Consejo</p> <p>Piensa en este ciclo como un loop infinito: cada vez que quieras contribuir \u2192 primero <code>pull</code>, despu\u00e9s <code>add</code> + <code>commit</code>, y finalmente <code>push</code>.</p>"}]}